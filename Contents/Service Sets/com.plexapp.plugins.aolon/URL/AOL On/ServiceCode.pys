VIDEO_URL = 'http://on.aol.com/video/%s'
JSON_DATA_URL = 'http://syn.5min.com/handlers/SenseHandler.ashx?func=GetResults&playlist=%s&url=http'

RE_VIDEO_ID = Regex('(videoid|playlist)=(?P<video_id>\d+)', Regex.IGNORECASE)
RE_VIDEO_URL = Regex('videoUrl=(?P<video_url>[^&]+)')

MediaObject.container = Container.MP4
MediaObject.video_codec = VideoCodec.H264
MediaObject.audio_codec = AudioCodec.AAC
MediaObject.audio_channels = 2
MediaObject.optimized_for_streaming = True

HTTP.CacheTime = CACHE_1WEEK

####################################################################################################
def NormalizeURL(url):

	video_id = None

	if 'on.aol.com/video/' in url and len(url.split('-')) > 1:
		url = url.split('?')[0]
		video_id = url.split('-')[-1]
	elif 'on.aol.com/playlist/' in url and not 'videoid=' in url:
		html = HTML.ElementFromURL(url)
		embed_url = html.xpath('//meta[@property="og:video"]/@content')[0]
		video_id = embed_url.split('/')[-1].split('&')[0]
	elif not 'on.aol.com/video/' in url:
		video_id = RE_VIDEO_ID.search(url).group('video_id')

	if video_id:
		return VIDEO_URL % video_id
	else:
		return url

####################################################################################################
def MetadataObjectForURL(url):

	video_id = url.split('/')[-1]
	json_obj = JSON.ObjectFromURL(JSON_DATA_URL % (video_id))

	if 'success' in json_obj and json_obj['success']:
		json_obj = json_obj['binding'][0]
	else:
		raise Ex.MediaNotAvailable

	title = json_obj['Title']
	thumb = '%s_c_o.jpg' % json_obj['ThumbURL'].rsplit('_c', 1)[0]
	duration = Datetime.MillisecondsFromString(json_obj['Duration'])

	html = HTML.ElementFromURL(url)
	summary = html.xpath('//meta[@property="og:description"]/@content')[0]

	try:
		date = html.xpath('//span[contains(@class, "creation-date")]/text()')[0].split(': ')[-1]
		date = Datetime.ParseDate(date).date()
	except:
		date = None

	return VideoClipObject(
		title = title,
		summary = summary,
		duration = duration,
		thumb = Resource.ContentsOfURLWithFallback(url=thumb),
		originally_available_at = date
	)

####################################################################################################
def MediaObjectsForURL(url):

	return [
		MediaObject(
			parts = [PartObject(key=Callback(PlayVideo, url=url, rendition_id=8))],
			video_resolution = '1080'
		),
		MediaObject(
			parts = [PartObject(key=Callback(PlayVideo, url=url, rendition_id=4))],
			video_resolution = '720'
		),
		MediaObject(
			parts = [PartObject(key=Callback(PlayVideo, url=url, rendition_id=2))],
			video_resolution = '480'
		),
		MediaObject(
			parts = [PartObject(key=Callback(PlayVideo, url=url, rendition_id=1))],
			video_resolution = '360'
		)
	]

####################################################################################################
@indirect
def PlayVideo(url, rendition_id=8):

	video_id = url.split('/')[-1]
	json_obj = JSON.ObjectFromURL(JSON_DATA_URL % (video_id))

	if 'success' in json_obj and json_obj['success']:
		json_obj = json_obj['binding'][0]
	else:
		raise Ex.MediaNotAvailable

	embed_url = json_obj['EmbededURL']
	video_url = String.Unquote(RE_VIDEO_URL.search(embed_url).group('video_url'))

	renditions = [8, 4, 2, 1]
	index = renditions.index(rendition_id)

	while index < len(renditions):
		for rendition in json_obj['Renditions']:
			if rendition['RenditionType'] == 'mp4' and rendition['ID'] == renditions[index]:
				video_url = video_url.replace('.mp4', '_%d.mp4' % rendition['ID'])

				return IndirectResponse(VideoClipObject, key=video_url)

		index = index + 1

	raise Ex.MediaNotAvailable
