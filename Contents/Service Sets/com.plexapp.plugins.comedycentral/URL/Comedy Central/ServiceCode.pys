MRSS_URL = 'http://www.comedycentral.com/feeds/mrss?uri=%s'
NAMESPACES = {'media': 'http://search.yahoo.com/mrss/'}
MP4_URL = 'http://mtvnmobile.vo.llnwd.net/kip0/_pxn=0+_pxK=18639+_pxE=/44620/mtvnorigin/%s'

MediaObject.container = Container.MP4
MediaObject.video_codec = VideoCodec.H264
MediaObject.audio_codec = AudioCodec.AAC
MediaObject.audio_channels = 2
MediaObject.optimized_for_streaming = True
####################################################################################################
def MetadataObjectForURL(url):

	try:
		mgid = HTML.ElementFromURL(url, cacheTime=CACHE_1HOUR).xpath('//div[@id="video_player_box"]/@data-mgid')
		if len(mgid) < 1:
			raise Ex.MediaNotAvailable
	except:
		raise Ex.MediaNotAvailable

	try:
		xml = XML.ElementFromURL(MRSS_URL % mgid[0], cacheTime=CACHE_1HOUR)
	except Ex.HTTPError, e:
		raise Ex.MediaNotAvailable

	title = xml.xpath('//channel/title/text()')[0]
	summary = xml.xpath('//channel/description/text()')[0]

	duration = 0
	for timecode in xml.xpath('//item//media:content/@duration', namespaces=NAMESPACES):
		duration += int(float(timecode) * 1000)

	try:
		thumb = xml.xpath('//channel/image/url/text()')[0].split('?')[0].replace('/cc/', '/')
	except:
		thumb = ''

	try:
		date = Datetime.ParseDate(xml.xpath('//item[1]/pubDate')[0].text).date()
	except:
		date = None

	return VideoClipObject(
		title = title,
		summary = summary,
		duration = duration if duration > 0 else None,
		originally_available_at = date,
		thumb = Resource.ContentsOfURLWithFallback(url=thumb)
	)

####################################################################################################
@deferred
def MediaObjectsForURL(url):

	try:
		mgid = HTML.ElementFromURL(url, cacheTime=CACHE_1HOUR).xpath('//div[@id="video_player_box"]/@data-mgid')
		if len(mgid) < 1:
			raise Ex.MediaNotAvailable
	except:
		raise Ex.MediaExpired

	mrss_data = XML.ElementFromURL(MRSS_URL % mgid[0])
	media_urls = mrss_data.xpath('//media:content[@medium="video"]', namespaces=NAMESPACES)

	available_streams = {}
	bitrates = []
	index = 0

	while index < len(media_urls):
		player_url = media_urls[index].get('url')
		try:
			player_data = XML.ElementFromURL(player_url)
		except:	
			raise Ex.MediaNotAvailable
		mediagen_list = player_data.xpath('//rendition')
		if len(mediagen_list)<1:	
			raise Ex.MediaNotAvailable
		# Make sure the value for the first rtmp url listed is not a "video unavailable" image. 
		# If the value for the rtmp url is a png file, delete this part/media from the media_url list and continue
		first_rend = player_data.xpath('//rendition/src//text()')[0]
		if first_rend.endswith('.png'):	
			media_url.pop(index)
			Log('This media is an image and the video is no longer available')
			continue
            
		for rendition in mediagen_list:
			duration = rendition.get('duration')
			try:
				height = RE_RES_BIT.search(rtmp_url).group(1)
				bitrate = RE_RES_BIT.search(rtmp_url).group(2)
			except:
				height = rendition.get('height')
				bitrate = rendition.get('bitrate')
			rtmp_url = rendition.xpath('./src')[0].text
			if '/viacomccstrm/' in rtmp_url:
				stream_url = rtmp_url.split('/viacomccstrm/')[1]
			else:
				# This means one of the parts failed. Could be a url format that is not mentioned above or could be a not avail url
				Log('failed to split the rmtp_url to build the stream url. Its value is %s' %rtmp_url)
				raise Ex.MediaNotAvailable
			mp4_url = MP4_URL % stream_url
            
			# Not sure if we need the higher work of MTV URL service here to make sure the streams are all correct
			if unicode(bitrate) in available_streams.keys():
				available_streams[unicode(bitrate)][unicode(index)] = {"height":height,"mp4_url":mp4_url,"duration":duration}
			else:
				available_streams[unicode(bitrate)] = {}
				available_streams[unicode(bitrate)][unicode(index)] = {"height":height,"mp4_url":mp4_url,"duration":duration}
			if bitrate not in bitrates:
				bitrates.append(bitrate)

		index += 1

	bitrates.reverse()

	media_objects = []

	for bitrate in bitrates:
		i = 0
		parts = []
		while i < len(media_urls):
			parts.append(
				PartObject(key=available_streams[unicode(bitrate)][unicode(i)]["mp4_url"], duration=int(available_streams[unicode(bitrate)][unicode(i)]["duration"])*1000)
			)
			i += 1
		media_objects.append(
			MediaObject(
				parts=parts,
				# June 9, 2014 - The line below is necessary due to an issue with some clients not copying the media attributes for audio to the streams. 
				# Not including this line causes the Roku to transcode videos. This issue should be fixed in future versions of the client and/or framework.
				audio_codec = AudioCodec.AAC,
				bitrate = int(bitrate),
				video_resolution = int(available_streams[unicode(bitrate)][unicode(0)]["height"])
			)
		)
	return media_objects

####################################################################################################
def TestURLs():

	test_urls = []

	for episode in HTML.ElementFromURL('http://www.comedycentral.com/shows').xpath('//a[contains(@href, "/episodes/")]'):
		url = episode.get('href')

		if not url.startswith('http'):
			url = 'http://www.comedycentral.com%s' % url

		try:
			# It appears that sometimes links can be invalid. We should quickly test it before considering
			# using it as a Test URL.
			headers = HTTP.Request(url).headers
			test_urls.append(url)
		except: pass

		if len(test_urls) > 2:
			break

	return test_urls
