import re
import urllib2

DETAILS_URL = 'http://current.com/x/%s/context=slide'
THUMB_END = '_400x300.jpg'
FLV_END = '.flv'

####################################################################################################
def MetadataObjectForURL(url):

    content_id = re.match(".*/(?P<id>[0-9]+)_.*", url).groupdict()['id']

    # Extract the information from the page...
    details_page = XML.ElementFromURL(DETAILS_URL % content_id)
    title = details_page.xpath("//contentTitle/text()")[0]
    description = details_page.xpath("//contentText/text()")[0]
    thumb = details_page.xpath("//thumbUrl/text()")[0] + THUMB_END
    date = details_page.xpath("//dateAdded/text()")[0]
    date = Datetime.ParseDate(date)

    return VideoClipObject(
        title = title,
        summary = description,
        thumb = thumb,
        originally_available_at = date)

####################################################################################################
def MediaObjectsForURL(url):

  if url.find("/videos/") != -1:
    return [
      MediaObject(
        video_codec = VideoCodec.VP6,
        audio_codec = AudioCodec.MP3,
        container = 'flv',
        parts = [PartObject(key=Callback(PlayVideo, url = url))]
      )
    ]

  return [
    MediaObject(
      container = Container.MP4,
      video_codec = VideoCodec.H264,
      audio_codec = AudioCodec.AAC,
      video_resolution = "1080",
      optimized_for_streaming = True,
      audio_channels = 2,
      parts = [PartObject(key=Callback(PlayYTVideo, url = url, res = "1080"))]
    ),
    MediaObject(
      container = Container.MP4,
      video_codec = VideoCodec.H264,
      audio_codec = AudioCodec.AAC,
      video_resolution = "720",
      optimized_for_streaming = True,
      audio_channels = 2,
      parts = [PartObject(key=Callback(PlayYTVideo, url = url, res = "720"))]
    ),
    MediaObject(
      container = Container.MP4,
      video_codec = VideoCodec.H264,
      audio_codec = AudioCodec.AAC,
      video_resolution = "480",
      optimized_for_streaming = True,
      audio_channels = 2,
      parts = [PartObject(key=Callback(PlayYTVideo, url = url, res = "480"))]
    ),
    MediaObject(
      container = Container.MP4,
      video_codec = VideoCodec.H264,
      audio_codec = AudioCodec.AAC,
      video_resolution = "sd",
      optimized_for_streaming = True,
      audio_channels = 2,
      parts = [PartObject(key=Callback(PlayYTVideo, url = url, res = "sd"))]
    )
  ]

####################################################################################################
def PlayVideo(url):

    content_id = re.match(".*/(?P<id>[0-9]+)_.*", url).groupdict()['id']
    details_page = XML.ElementFromURL(DETAILS_URL % content_id)
    video_url = details_page.xpath("//assetUrl/text()")[0]

    # It appears that the file extension is only sometimes present. Also, sometimes a URL is specified
    # which ends in what looks like an extension, but actually it needs a further one! e.g. .flv.flv!
    if IsAvailable(video_url) == False:
        video_url = video_url + FLV_END

    return Redirect(video_url)

####################################################################################################

@indirect
def PlayYTVideo(url, res):

  # Find the external source and the available media objects.
  page = HTML.ElementFromURL(url)
  external_source = page.xpath("//embed[@wmode='transparent']")[0].get('src')
  media = URLService.MediaObjectsForURL(external_source)

  resolutions = ["1080", "720", "480", "sd"]
  index = resolutions.index(res)
  for resolution_index in range(index, len(resolutions)):
    current_resolution = resolutions[resolution_index]
    for video in media:
      if video.video_codec != VideoCodec.H264:
        continue
      if str(video.video_resolution) == current_resolution:
        return Redirect(video.parts[0].key)

  return Redirect(media[-1].parts[0].key)

####################################################################################################
class HeadRequest(urllib2.Request):
    def get_method(self):
        return "HEAD"

def IsAvailable(url):
    try:
        response = urllib2.urlopen(HeadRequest(url))
        return True
    except:
        return False

####################################################################################################
def TestURLs():
    test_urls = []

    page = HTML.ElementFromURL("http://current.com/")

    for link in page.xpath("//li[contains(@class, 'item')]//a[contains(@href, 'http')]"):
        if len(test_urls) < 3:
            url = link.get('href')

            if re.match("http://current.com/.+/[0-9]+_.+", url) == None:
                continue

            if url not in test_urls:
                test_urls.append(url)
        else:
            break

    return test_urls
