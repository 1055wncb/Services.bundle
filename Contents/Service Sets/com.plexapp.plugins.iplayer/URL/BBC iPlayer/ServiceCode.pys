httpHeaders = { 'User-Agent' : 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en-US; rv:1.9.2.17) Gecko/20110420 Firefox/3.6.17' }
RE_PID = Regex('iplayer/episode/([^/$]{8})')
RE_DETAILS = Regex('episodeRegistry.addData\([^{]*(.+)\)+')
NAMESPACES = {'m': 'http://bbc.co.uk/2008/mp/mediaselection'}

####################################################################################################
def NormalizeURL(url):

  return url

####################################################################################################
def MetadataObjectForURL(url):

  pid = RE_PID.findall(url)[0]
  thumb = 'http://node2.bbcimg.co.uk/iplayer/images/episode/%s_640_360.jpg' % pid
  programme = JSON.ObjectFromURL('http://www.bbc.co.uk/programmes/%s.json' % pid, headers=httpHeaders)['programme']

  if programme['long_synopsis']:
    summary = programme['long_synopsis']
  elif programme['medium_synopsis']:
    summary = programme['medium_synopsis']
  elif programme['short_synopsis']:
    summary = programme['short_synopsis']
  else:
    summary = ''

  originally_available_at = Datetime.ParseDate(programme['first_broadcast_date']).date()
  duration = programme['versions'][0]['duration']

  if 'parent' in programme:
    parent_programme = programme['parent']['programme']
    if parent_programme['type'] == 'series':
      # Create an EpisodeObject...
      show_title = parent_programme['parent']['programme']['title'] if 'parent' in parent_programme else parent_programme['title']
      episode_title = programme['display_title']['subtitle']

      try: season = parent_programme['position']
      except: season = None

      try: episode = programme['position']
      except: episode = None

      video = EpisodeObject(
        show = show_title,
        title = episode_title,
        season = season,
        index = episode,
        summary = summary,
        originally_available_at = originally_available_at,
        duration = duration * 1000,
        thumb = thumb
      )

    if programme['parent']['programme']['type'] == 'brand':
      # Create a VideoClipObject...
      title = programme['display_title']['title']

      video = VideoClipObject(
        title = title,
        summary = summary,
        originally_available_at = originally_available_at,
        duration = duration * 1000,
        thumb = thumb
      )

  elif 'categories' in programme:
    for category in programme['categories']:
      # If this is a film...
      if category['title'] == 'Films':
        # Create a MovieObject...
        title = programme['display_title']['title']

        video = MovieObject(
          title = title,
          summary = summary,
          originally_available_at = originally_available_at,
          duration = duration * 1000,
          thumb = thumb
        )

        break

      # If this is a documentary...
      elif category['title'] == 'Documentaries':
        title = programme['display_title']['title']
        # Create a VideoClipObject...
        video = VideoClipObject(
          title = title,
          summary = summary,
          originally_available_at = originally_available_at,
          duration = duration * 1000,
          thumb = thumb
        )

        break

  return video

####################################################################################################
def MediaObjectsForURL(url):
  return [
    MediaObject(
      container = Container.MP4,
      video_codec = VideoCodec.H264,
      audio_codec = AudioCodec.AAC,
      video_resolution = '720',
      audio_channels = 2,
      parts = [PartObject(key=Callback(PlayVideo, url = url, height = '720'))],
    ),
    MediaObject(
      container = Container.MP4,
      video_codec = VideoCodec.H264,
      audio_codec = AudioCodec.AAC,
      video_resolution = '486',
      audio_channels = 2,
      parts = [PartObject(key=Callback(PlayVideo, url = url, height = '486'))],
    ),
    MediaObject(
      container = Container.MP4,
      video_codec = VideoCodec.H264,
      audio_codec = AudioCodec.AAC,
      video_resolution = 'sd',
      audio_channels = 2,
      parts = [PartObject(key=Callback(PlayVideo, url = url, height = '360'))],
    )
  ]

####################################################################################################
@indirect
def PlayVideo(url, height):
  page_contents = HTTP.Request(url).content
  details_json = RE_DETAILS.findall(page_contents)[0]
  details = JSON.ObjectFromString(details_json)

  pid = RE_PID.findall(url)[0]
  pid_details = details[pid]

  stream_details = XML.ElementFromURL(pid_details['my_mediaselector_xml_url'])

  last_stream = None
  heights = ['720', '486', '360']
  index = heights.index(height)
  for height_index in range(index, len(heights)):
    Log("IABI: " + '//m:media[@kind = "video" and @height = "%s"]/m:connection[@protocol = "rtmp"]' % heights[height_index])
    streams = stream_details.xpath('//m:media[@kind = "video" and @height = "%s"]/m:connection[@protocol = "rtmp"]' % heights[height_index], namespaces = NAMESPACES)
    if len(streams) > 0:
      stream = streams[0]
      break
  
  server = stream.get('server')
  auth = stream.get('authString')

  supplier = stream.get('supplier')
  application = stream.get('application')
  if application is None and supplier == 'akamai':
    application = 'ondemand'

  rtmp_url = 'rtmp://%s/%s?%s' % (server, application, auth)

  clip = stream.get('identifier')
  swf_url = 'http://www.bbc.co.uk/emp/10player.swf'
  Log(rtmp_url)
  Log(clip)
  return IndirectResponse(VideoClipObject, key = RTMPVideoURL(url = rtmp_url, clip = clip, swf_url = swf_url))
