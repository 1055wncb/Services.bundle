import re, urlparse

# allow any length for these content types
valid_types = ['text/html', 'application/xhtml+xml']

# only allow response sizes below a certain length for arbitrary types
max_length = 1024

PATTERN = Regex('("|\'|&quot;|%22)(?P<vid>(https?(:|%3A)(//|%2F%2F)|(/|%2F)).+?\.(m3u8|mov|mp(e)?g|avi|mkv|mp4|flv)((\?|%3F).+?)?)("|\'|&quot;|%22)')

####################################################################################################
def FixUrl(parent_url, url):

	parent_url = urlparse.urlparse(parent_url)

	if url and url[0] == '/':
		# Absolute path.
		final_url = '%s://%s%s' % (parent_url.scheme, parent_url.netloc, url)
	elif url and url.find('://') == -1:
		# Relative path.
		final_url = '%s://%s%s/%s' % (parent_url.scheme, parent_url.netloc, parent_url.path.rsplit('/',1)[0], url)
	else:
		final_url = url

	return final_url

####################################################################################################
def ShouldParse(req):

	# Check the content type and content length headers
	try:
		content_type = req.headers['content-type'].split(';')[0].strip()
	except:
		content_type = 'Unknown'
	try:
		content_length = int(req.headers['content-length'])
	except:
		content_length = 0

	Log("Length: %d  Type: %s", content_length, content_type)
	if (content_length <= 0 or content_length > max_length) and content_type not in valid_types:
		Log("Content length for unknown type %s is invalid - aborting", content_type)
		return False

	return True

####################################################################################################
def MetadataObjectForURL(url):

	req = HTTP.Request(url)

	if ShouldParse(req):
		doc = req.content
		video = PATTERN.search(doc)

		if not video:
			return None

		return VideoClipObject(
			title = HTML.ElementFromString(doc).xpath('//title')[0].text.strip()
		)

####################################################################################################
def MediaObjectsForURL(url):

	req = HTTP.Request(url)

	if ShouldParse(req):
		doc = req.content
		video = PATTERN.search(doc)

		if not video:
			return None

		src = video.group('vid')
		src = String.Unquote(src)
		src = FixUrl(url, src)

		if src.find('.m3u8') != -1:
			return [
				MediaObject(
					parts = [PartObject(key=HTTPLiveStreamURL(src))],
					container = 'mpegts'
				)
			]
		else:
			return [
				MediaObject(
					parts = [PartObject(key=src)]
				)
			]
