SSL_CAPABLE_CLIENTS = ['Android', 'iOS', 'Roku', 'Safari', 'Firefox', 'Chrome']
RE_KEY_URI = Regex('URI *= *"(.*)"')

####################################################################################################
def NormalizeURL(url):
    return url

####################################################################################################
def MetadataObjectForURL(url):
	try:
		page = HTML.ElementFromURL(url)
	except:
		raise Ex.MediaNotAvailable

	# Test if this page contains video
	json_url = page.xpath('//a[@id="player"]/@data-json-href')
	if len(json_url) < 1:
		return None

	show = None
	title = page.xpath('//meta[@property="og:title"]/@content')[0].split(' | ')[0].replace('&amp;', '&')
	title = String.DecodeHTMLEntities(title)

	if ' - ' in title:
		(show, title) = title.split(' - ', 1)

	summary = page.xpath('//meta[@property="og:description"]/@content')[0].replace('&amp;', '&')
	summary = String.DecodeHTMLEntities(summary)
	thumb = page.xpath('//meta[@property="og:image"]/@content')

	if len(thumb) < 1:
		thumb = None
	else:
		thumb = thumb[0].replace('/small/', '/large/')

	try:
		air_date = page.xpath('//div[@class="playBoxConnectedToVideoMain"]//time/@datetime')[0].split('T')[0]
		air_date = Datetime.ParseDate(air_date).date()
	except:
		air_date = None

	# Airdate for Ã–ppet Arkiv
	if air_date == None:
		try:
			air_date = page.xpath("//span[@class='svt-video-meta']//time/@datetime")[0].split('T')[0]
			air_date = Datetime.ParseDate(air_date).date()
		except:
			air_date = None

	try:
		duration = page.xpath("//a[@id='player']/@data-length")
		duration = int(duration[0]) * 1000
	except:
		duration = None
		pass

	if show:
		return EpisodeObject(
			show = show,
			title = title,
			summary = summary,
			duration = duration,
			thumb = thumb,
			originally_available_at = air_date
		)
	else:
		return VideoClipObject(
			title = title,
			summary = summary,
			duration = duration,
			thumb = thumb,
			originally_available_at = air_date
		)

####################################################################################################
def MediaObjectsForURL(url):

	return [
		MediaObject(
			parts = [
				PartObject(key=HTTPLiveStreamURL(Callback(PlayVideo, url=url)))
			],
			audio_channels = 2,
			optimized_for_streaming = True
		)
	]

####################################################################################################
def PlayVideo(url):
	json_obj = JSON.ObjectFromURL(url + '?output=json')
	playlist_url = None
	
	for item in json_obj['video']['videoReferences']: 
		if '.m3u8' in item['url']:
			playlist_url = item['url']
			break
		elif '.f4m' in item['url']:
			playlist_url = item['url'].replace("/z/", "/i/").replace("manifest.f4m", "master.m3u8")

	if playlist_url:
		if Client.Platform in SSL_CAPABLE_CLIENTS:
			return Redirect(playlist_url)
		else:
			streams = GetHLSStreams(playlist_url)
			
			if 'svtplay' in playlist_url:
				playlist = CreatePatchedPlaylist(streams[0]['url'])
				return playlist
			else:
				return Redirect(streams[0]['url'])
	else:
		raise Ex.MediaNotAvailable

####################################################################################################
def GetHLSStreams(url):
	streams = []

	playlist = HTTP.Request(url).content

	# Parse the m3u8 file to get:
	# - URL
	# - Resolution
	# - Bitrate
	for line in playlist.splitlines():
		if "BANDWIDTH" in line:
			stream            = {}
			stream["bitrate"] = int(Regex('(?<=BANDWIDTH=)[0-9]+').search(line).group(0))        

			if "RESOLUTION" in line:
				stream["resolution"] = int(Regex('(?<=RESOLUTION=)[0-9]+x[0-9]+').search(line).group(0).split("x")[1])
			else:
				stream["resolution"] = 0

		elif ".m3u8" in line:
			path = ''
			if not line.startswith("http"):
				path = url[ : url.rfind('/') + 1]

			stream["url"] = path + line

			streams.append(stream)

	sorted_streams = sorted(streams, key = lambda stream: stream["bitrate"], reverse = True)        

	return sorted_streams

####################################################################################################
def CreatePatchedPlaylist(url):
	original_playlist = HTTP.Request(url).content
	new_playlist = ''

	for line in original_playlist.splitlines():
		if line.startswith('#EXT-X-KEY'):
			original_key_url = RE_KEY_URI.search(line).groups()[0]
			new_key_url = Callback(ContentOfHTTPSURL, url = original_key_url)
			new_playlist = new_playlist + line.replace(original_key_url, new_key_url) + '\n'
		elif line.startswith('https'):
			original_segment_url = line
			new_segment_url = Callback(ContentOfHTTPSURL, url = original_segment_url)
			new_playlist = new_playlist + new_segment_url + '\n'
		else:
			new_playlist = new_playlist + line + '\n'
	
	return new_playlist
	
####################################################################################################
def ContentOfHTTPSURL(url):
	return HTTP.Request(url).content
