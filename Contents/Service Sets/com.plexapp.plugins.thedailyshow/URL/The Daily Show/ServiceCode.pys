MRSS_URL = 'http://thedailyshow.cc.com/feeds/mrss?uri=%s'
NAMESPACES = {'media': 'http://search.yahoo.com/mrss/'}

RE_FIX_XML = Regex('(<!--.*?-->)')

####################################################################################################
def NormalizeURL(url):

	return url.split('?')[0]

####################################################################################################
def MetadataObjectForURL(url):

	try:
		html = HTML.ElementFromURL(url, cacheTime=CACHE_1HOUR)
	except Ex.HTTPError, e:
		if e.code == 404:
			Log('HTTP 404 Not Found for URL: %s' % url)
			raise Ex.MediaNotAvailable
	except:
		raise Ex.MediaNotAvailable

	title = html.xpath('//meta[@property="og:title"]/@content')[0]
	summary = html.xpath('//meta[@property="og:description"]/@content')[0]
	thumb = html.xpath('//meta[@property="og:image"]/@content')[0].split('?')[0]
	duration = 0

	try:
		mgid = html.xpath('//div[contains(@id, "video_player")]/@data-mgid')

		if len(mgid) < 1:
			raise Ex.MediaExpired

		mrss_data = HTTP.Request(MRSS_URL % mgid[0], cacheTime=CACHE_1HOUR).content
		mrss_data = RE_FIX_XML.sub('', mrss_data)
		mrss_data = XML.ElementFromString(mrss_data)

		media_urls = mrss_data.xpath('//media:content[@medium="video"]', namespaces=NAMESPACES)

		for segment in media_urls:
			if segment.get('duration') != "":
				if ':' in segment.get('duration'):
					duration += Datetime.MillisecondsFromString(segment.get('duration'))
				else:
					duration += int(float(segment.get('duration'))*1000)
	except:
		pass

	if '/full-episodes/' in url:

		try:
			air_date = html.xpath('//title')[0].text.split(' - ')[0].strip()
			originally_available_at = Datetime.ParseDate(air_date)
		except:
			originally_available_at = None

		return EpisodeObject(
			show = 'The Daily Show',
			title = title,
			summary = summary,
			duration = duration,
			thumb = Resource.ContentsOfURLWithFallback(url=thumb),
			originally_available_at = originally_available_at
		)

	elif '/videos/' in url:

		try:
			air_date = html.xpath('//li[@class="airDate"]/text()')[0].strip()
			originally_available_at = Datetime.ParseDate(air_date)
		except:
			originally_available_at = None

		return VideoClipObject(
			title = title,
			summary = summary,
			duration = duration,
			thumb = Resource.ContentsOfURLWithFallback(url=thumb),
			originally_available_at = originally_available_at
		)

####################################################################################################
@deferred
def MediaObjectsForURL(url):

	try:
		mgid = HTML.ElementFromURL(url, cacheTime=CACHE_1HOUR).xpath('//div[contains(@id, "video_player")]/@data-mgid')

		if len(mgid) < 1:
			raise Ex.MediaNotAvailable
	except:
		raise Ex.MediaExpired

	mrss_data = HTTP.Request(MRSS_URL % mgid[0], cacheTime=CACHE_1HOUR).content
	mrss_data = RE_FIX_XML.sub('', mrss_data)
	mrss_data = XML.ElementFromString(mrss_data)

	media_urls = mrss_data.xpath('//media:content[@medium="video"]/@url', namespaces=NAMESPACES)
	parts = []
	total_duration = 0

	for media_url in media_urls:

		try:
			media_url = media_url.replace('{device}', 'iPad')
			video_data = XML.ElementFromURL(media_url, cacheTime=CACHE_1HOUR)
		except:
			raise Ex.MediaNotAvailable

		rendition = video_data.xpath('//rendition[@type="application/x-mpegURL"]')

		if len(rendition) < 1:
			raise Ex.MediaNotAvailable

		parts.append(
			PartObject(
				key = HTTPLiveStreamURL(rendition[0].xpath('./src/text()')[0]),
				duration = int(rendition[0].get('duration'))*1000
			)
		)

	if len(parts) > 0:

		return [
			MediaObject(
				parts = parts,
				video_resolution = 540
			)
		]

	raise Ex.MediaNotAvailable
