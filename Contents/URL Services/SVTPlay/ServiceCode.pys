import re

DETAILS_URL = 'http://xml.svtplay.se/v1/videos/%s'
NS_SVT = { 'svtplay': 'http://xml.svtplay.se/ns/playrss', 'media': 'http://search.yahoo.com/mrss/' }

CATEGORY_EPISODES = [ '96240', '96241', '96247' ]
CATEGORY_MOVIES = [ '96242' ]

####################################################################################################

def MetadataObjectForURL(url):
    try:

        # Request the page
        page = HTML.ElementFromURL(url)

        # If this page contains a video element, we should be able to extract out the video id
        # associated with the content.
        player_details = page.xpath("//div[@id = 'player']")[0].get('class')
        video_id = re.match(".*'(?P<id>[0-9]+)'.*", player_details).groupdict()['id']

        # Using the known video id, we can now obtain an XML page which contains all of the details
        # associated with the title.
        details_page = XML.ElementFromURL(DETAILS_URL % video_id)

        root = details_page.xpath("//item", namespaces = NS_SVT)[0]
        title = root.xpath("//title/text()", namespaces = NS_SVT)[0]
        thumb = root.xpath("//media:content[@medium='image']", namespaces = NS_SVT)[0].get('url')
        date = root.xpath("//pubDate/text()", namespaces = NS_SVT)[0]
        date = Datetime.ParseDate(date)

        description = None
        try: description = root.xpath("//description/text()", namespaces = NS_SVT)[0]
        except: pass

        duration = None
        duration_nodes = root.xpath("//media:content[string-length(@duration) > 0]", namespaces = NS_SVT)
        if len(duration_nodes) > 0:
            duration = int(duration_nodes[0].get('duration'))

        # If the found title is an episode, we should be able to extract more information and return
        # the suitable EpisodeObject.
        category = root.xpath("//svtplay:category/text()", namespaces = NS_SVT)[0]
        if category in CATEGORY_EPISODES:

            show = root.xpath("//svtplay:titleName/text()", namespaces = NS_SVT)[0]
            episode_number = int(root.xpath("//svtplay:programInfo", namespaces = NS_SVT)[0].get('episodeNo'))

            return EpisodeObject(
                show = show,
                title = title,
                index = episode_number,
                summary = description,
                thumb = thumb,
                duration = duration,
                originally_available_at = date)
                
        # If the found title is a move, we should simply return the appropriate MovieObject
        if category in CATEGORY_MOVIES:

            return MovieObject(
                title = title,
                summary = description,
                thumb = thumb,
                duration = duration,
                originally_available_at = date)

        # We've not identified a specific category for the associated title. Therefore we should
        # simply return a generic VideoClipObject.
        return VideoClipObject(
            title = title,
            summary = description,
            thumb = thumb,
            duration = duration,
            originally_available_at = date)

    except:
        Log.Exception("An error occurred while attempting to retrieve the required meta data.")

####################################################################################################

def MediaObjectsForURL(url):
    return [
      MediaObject(
        container = Container.MP4,
        protocols = [Protocol.RTMP],
        video_resolution = "720",
        bitrate = "2400",
        parts = [PartObject(key=Callback(PlayVideo, url = url, res = "720"))]
      ),
      MediaObject(
        container = Container.MP4,
        protocols = [Protocol.RTMP],
        video_resolution = "576",
        bitrate = "1400",
        parts = [PartObject(key=Callback(PlayVideo, url = url, res = "576"))]
      ),
      MediaObject(
        container = Container.MP4,
        protocols = [Protocol.RTMP],
        video_resolution = "360",
        bitrate = "850",
        parts = [PartObject(key=Callback(PlayVideo, url = url, res = "360"))]
      )
    ]

####################################################################################################

def PlayVideo(url, res):

    # Request the page
    page = HTML.ElementFromURL(url)

    # If this page contains a video element, we should be able to extract out the video id
    # associated with the content.
    player_details = page.xpath("//div[@id = 'player']")[0].get('class')
    video_id = re.match(".*'(?P<id>[0-9]+)'.*", player_details).groupdict()['id']

    # Using the known video id, we can now obtain an XML page which contains all of the details
    # associated with the title.
    details_page = XML.ElementFromURL(DETAILS_URL % video_id)

    # Find all the available RTMP streams.
    rtmp_streams = {}
    for resolution in [ "720", "576", "360" ]:
        rtmp_stream = details_page.xpath("//media:content[@type = 'video/mp4' and @height = '%s' and contains(@url, 'rtmp://')]" % resolution, namespaces = NS_SVT)
        if len(rtmp_stream) > 0:
            rtmp_streams[resolution] = rtmp_stream[0].get('url')

    # It's possible that the requested stream is not actually available. Therefore we will just fallback
    # to one which is actually present.
    rtmp_stream = None
    if rtmp_streams.has_key(res):
        stream = rtmp_streams[res]
    else:
        if len(rtmp_streams.keys()) > 0:
            rtmp_stream = rtmp_streams[rtmp_streams.keys()[0]]

    # FIXME: It's still possible that no RTMP streams are found (specially RTMPE).
    if rtmp_stream != None:
        rtmp_stream_details = rtmp_stream.split('_definst_')
        return Redirect(RTMPVideoItem(rtmp_stream_details[0], clip = "mp4:" + rtmp_stream_details[1]))